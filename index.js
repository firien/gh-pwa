// Generated by CoffeeScript 2.3.2
var $hashLength, PWAPlugin, UPNG, coffee, compactor, crypto, ejs, fs, hashString, path, pug, renderSync, sass;

fs = require('fs');

path = require('path');

coffee = require('coffeescript');

ejs = require('ejs');

sass = require('node-sass');

pug = require('pug');

crypto = require('crypto');

UPNG = require('upng-js');

$hashLength = 20;

// use with Array::filter (remove nulls and undefined)
compactor = function(item) {
  return item != null;
};

// webpack uses md4 by default
hashString = function(buf) {
  return crypto.createHash('md4').update(buf).digest('hex').substring(0, $hashLength);
};

// redner ejs
renderSync = function(filePath, locals) {
  var template;
  template = fs.readFileSync(filePath);
  return ejs.render(template.toString(), locals, {});
};

PWAPlugin = class PWAPlugin {
  constructor(options) {
    this.options = options;
  }

  generatePWA() {
    var hash, js, newFileName, scope, str, templatePath;
    templatePath = path.join(__dirname, 'templates/pwa.coffee.ejs');
    if (this.options.mode === 'production') {
      scope = `${this.options.scope}/`;
    } else {
      scope = '';
    }
    str = renderSync(templatePath, {
      scope: scope
    });
    js = coffee.compile(str);
    hash = hashString(js);
    newFileName = `pwa.${hash}.js`;
    return {
      name: newFileName,
      source: js,
      size: js.length
    };
  }

  generateServiceWorker(assets) {
    var assetKeys, js, locals, str, templatePath;
    if (this.options.mode === 'production') {
      assetKeys = Object.keys(assets).map(function(asset) {
        return `/${this.options.scope}/${asset}`;
      }, this);
      assetKeys.push(`/${this.options.scope}/`);
    } else {
      assetKeys = Object.keys(assets);
      assetKeys.push('/');
    }
    templatePath = path.join(__dirname, 'templates/service.coffee.ejs');
    locals = {
      tag: this.options.tag,
      app: this.options.scope,
      files: assetKeys
    };
    str = renderSync(templatePath, locals);
    js = coffee.compile(str);
    return {
      name: 'service.js',
      source: js,
      size: js.length
    };
  }

  // renders Pug files in /views/ to html
  renderViews(compilation) {
    var assetKeys, assetPath, desc, iconLinks, locals, name, pwa, scriptAttributes, themeColor;
    pwa = this;
    assetKeys = Object.keys(compilation.assets);
    // =================== start local pug definitions
    assetPath = function(_path) {
      var basename, extname, foundAsset, regex;
      extname = path.extname(_path);
      basename = path.basename(_path, extname);
      regex = new RegExp(`${basename}\\.[\\w]{${$hashLength}}\\${extname}`);
      foundAsset = assetKeys.find(function(asset) {
        return regex.test(asset);
      });
      if (foundAsset) {
        return foundAsset;
      } else {
        throw `could not find ${_path}`;
      }
    };
    // include sha256 integrity attribute
    scriptAttributes = function(_path) {
      var _asset, sha256;
      _path = assetPath(_path);
      _asset = compilation.assets[_path];
      sha256 = crypto.createHash('sha256').update(_asset.source()).digest('base64');
      return {
        src: _path,
        integrity: `sha256-${sha256}`
      };
    };
    // generate <links> for icon-*.png
    iconLinks = function() {
      var regex;
      regex = /icon-.*?\.png/i;
      return assetKeys.map(function(asset) {
        var png;
        if (regex.test(asset)) {
          png = UPNG.decode(compilation.assets[asset].source());
          return {
            rel: 'apple-touch-icon',
            sizes: `${png.width}x${png.height}`,
            href: asset
          };
        }
      }).filter(compactor);
    };
    themeColor = (function() {
      return this.options.theme_color;
    }).bind(this);
    desc = (function() {
      return this.options.description;
    }).bind(this);
    name = (function() {
      return this.options.name;
    }).bind(this);
    locals = {
      assetPath,
      scriptAttributes,
      iconLinks,
      themeColor,
      desc,
      name,
      pretty: true
    };
    // =================== end local pug definitions
    return fs.readdirSync('./views').map(function(fileName) {
      var filePath, html, newFileName;
      if (/\.pug/.test(fileName)) {
        filePath = path.resolve('./views', fileName);
        html = pug.renderFile(filePath, locals);
        newFileName = fileName.replace(/pug$/, 'html');
        // add dependencies
        compilation.fileDependencies.add(filePath);
        return {
          name: newFileName,
          source: html,
          size: html.length
        };
      }
    }).filter(compactor);
  }

  // transpiles Coffee files in /javascripts/ to js
  // directly copies plain js
  transpileCoffee(compilation) {
    return fs.readdirSync('./javascripts').map(function(fileName) {
      var cs, filePath, hash, js, newFileName, source;
      filePath = path.resolve('./javascripts', fileName);
      if (/\.coffee$/.test(fileName)) {
        compilation.fileDependencies.add(filePath);
        cs = fs.readFileSync(filePath, 'utf8');
        js = coffee.compile(cs);
        hash = hashString(js);
        newFileName = fileName.replace(/\.coffee$/, `.${hash}.js`);
        return {
          name: `javascripts/${newFileName}`,
          source: js,
          size: js.length
        };
      } else if (/\.js$/.test(fileName)) {
        compilation.fileDependencies.add(filePath);
        source = fs.readFileSync(filePath);
        hash = hashString(source);
        js = source.toString();
        newFileName = fileName.replace(/\.js$/, `.${hash}.js`);
        return {
          name: `javascripts/${newFileName}`,
          source: js,
          size: js.length
        };
      }
    }).filter(compactor);
  }

  // transpiles SASS files in /stylesheets/ to css
  // directly copies plain css
  transpileSass(compilation) {
    return fs.readdirSync('./stylesheets').map(function(fileName) {
      var css, filePath, hash, newFileName, result, source;
      filePath = path.resolve('./stylesheets', fileName);
      if (/\.scss/.test(fileName)) {
        compilation.fileDependencies.add(filePath);
        result = sass.renderSync({
          file: filePath
        });
        css = result.css.toString();
        hash = hashString(css);
        newFileName = fileName.replace(/\.scss$/, `.${hash}.css`);
        return {
          name: `stylesheets/${newFileName}`,
          source: css,
          size: css.length
        };
      } else if (/\.css$/.test(fileName)) {
        compilation.fileDependencies.add(filePath);
        source = fs.readFileSync(filePath);
        hash = hashString(source);
        css = source.toString();
        newFileName = fileName.replace(/\.css$/, `.${hash}.css`);
        return {
          name: `stylesheets/${newFileName}`,
          source: css,
          size: css.length
        };
      }
    }).filter(compactor);
  }

  copyImages(compilation) {
    if (fs.existsSync('./images')) {
      return fs.readdirSync('./images').map(function(fileName) {
        var extname, filePath, hash, imageData, newFileName, regexp;
        extname = path.extname(fileName);
        if (/png/i.test(extname)) {
          filePath = path.resolve('./images', fileName);
          compilation.fileDependencies.add(filePath);
          imageData = fs.readFileSync(filePath);
          hash = hashString(imageData);
          regexp = new RegExp(`\\${extname}$`);
          newFileName = fileName.replace(regexp, `.${hash}${extname}`);
          return {
            name: `images/${newFileName}`,
            source: imageData,
            size: imageData.length
          };
        }
      }).filter(compactor);
    } else {
      return [];
    }
  }

  generateManifest(assets) {
    var assetKeys, manifest, regex, str;
    assetKeys = Object.keys(assets);
    manifest = {
      name: this.options.name,
      short_name: this.options.short_name || this.options.name,
      start_url: '.',
      display: 'standalone',
      background_color: this.options.background_color || this.options.theme_color,
      theme_color: this.options.theme_color,
      description: this.options.description
    };
    regex = /icon-.*?\.png/i;
    manifest.icons = assetKeys.map(function(asset) {
      var png;
      if (regex.test(asset)) {
        png = UPNG.decode(assets[asset].source());
        return {
          src: asset,
          type: 'image/png',
          sizes: `${png.width}x${png.height}`
        };
      }
    }).filter(compactor);
    str = JSON.stringify(manifest, null, 4);
    return {
      name: 'manifest.webmanifest',
      source: str,
      size: str.length
    };
  }

  apply(compiler) {
    var pwa;
    pwa = this;
    return compiler.hooks.emit.tapAsync('PWAPlugin', function(compilation, callback) {
      var addAsset, faviconPath, imageData, outputPath;
      outputPath = compiler.outputPath;
      addAsset = function(asset) {
        return compilation.assets[asset.name] = {
          source: function() {
            return asset.source;
          },
          size: function() {
            return asset.source.length;
          }
        };
      };
      pwa.transpileCoffee(compilation).forEach(addAsset);
      pwa.transpileSass(compilation).forEach(addAsset);
      pwa.copyImages(compilation).forEach(addAsset);
      addAsset(pwa.generatePWA());
      addAsset(pwa.generateManifest(compilation.assets));
      pwa.renderViews(compilation).forEach(addAsset);
      addAsset(pwa.generateServiceWorker(compilation.assets));
      faviconPath = path.resolve('./favicon.ico');
      if (fs.existsSync(faviconPath)) {
        imageData = fs.readFileSync(faviconPath);
        addAsset({
          name: 'favicon.ico',
          source: imageData,
          size: imageData.length
        });
      }
      return callback();
    });
  }

};

// export default PWAPlugin
module.exports = PWAPlugin;
